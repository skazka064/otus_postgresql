# 
### Будем использовать следующую базу otus_ddl и некоторые примеры с сайта https://www.db-fiddle.com
```sql
CREATE DATABASE otus_dql;
```
### Создадим таблицы
```sql
CREATE TABLE buses (
    bus_id serial,
    name   varchar
);
CREATE TABLE drivers (
    driver_id   serial,
    first_name  varchar,
    second_name varchar
);


CREATE TABLE routes (
    route_id  serial,
    name      varchar,
    bus_id    int,
    driver_id int
);
```
### Заполним таблицы данными
```sql
INSERT INTO buses
       (bus_id, name)
VALUES (1, 'ПАЗ'),
       (2, 'ЛИАЗ'),
       (3, 'MAN'),
       (4, 'МАЗ'),
       (5, 'НЕФАЗ');

INSERT INTO drivers
       (driver_id, first_name, second_name)
VALUES (1, 'Иван', 'Иванов'),
       (2, 'Петр', 'Петров'),
       (3, 'Савелий', 'Сидоров'),
       (4, 'Антон', 'Шторкин'),
       (5, 'Олег', 'Зажигаев'),
       (6, 'Аркадий', 'Паровозов');

INSERT INTO routes
       (route_id, name, bus_id, driver_id)
VALUES (1, 'Москва-Болшево', 1, 1),
       (2, 'Москва-Пушкино', 1, 2),
       (3, 'Москва-Ярославль', 2, 3),
       (4, 'Москва-Кострома', 2, 4),
       (5, 'Москва-Волгорад', 3, 5),
       (6, 'Москва-Иваново', null, null);

```

![Маршруты и водители](/img/Screenshot_3.png "Маршруты и водители")


```sql
SELECT * FROM buses;
```

 <table>
    <tr>
    <th>bus_id</th>	<th>name</th>
    </tr>
    <tr>
    <td>1</td>	<td>ПАЗ</td>
    </tr>
    <tr>
    <td>2</td>	<td>ЛИАЗ</td>
    </tr>
    <tr>
    <td>3</td>	<td>MAN</td>
    </tr>
    <tr>
    <td>4</td>	<td>МАЗ</td>
    </tr>
    <tr>
    <td>5</td>	<td>НЕФАЗ</td>
    </tr>
 </table>  
 
```sql
SELECT * FROM drivers;
```
 <table>
    <tr>
    <th>driver_id</th>	<th>First_name</th><th>Second_name</th>
    </tr>
    <tr>
    <td>1</td>	<td>Иван</td><td>Иванов</td>
    </tr>
    <tr>
    <td>2</td>	<td>Петр</td><td>Петров</td>
    </tr>
    <tr>
    <td>3</td>	<td>Савелий</td><td>Сидоров</td>
    </tr>
    <tr>
    <td>4</td>	<td>Антон</td><td>Шторкин</td>
    </tr>
    <tr>
    <td>5</td>	<td>Олег</td><td>Зажигаев</td>
    </tr>
    <tr>
    <td>6</td>	<td>Аркадий</td><td>Паровозов</td>
    </tr>
 </table>

 ```sql
SELECT * FROM routes;
```
 <table>
    <tr>
    <th>route_id</th>	<th>name</th><th>bus_id</th><th>driver_id</th>
    </tr>
     <tr>
    <td>1</td>	<td>Москва-Болшево</td><td>1</td><td>1</td>
    </tr>
      <tr>
    <td>2</td>	<td>Москва-Пушкино</td><td>1</td><td>2</td>
    </tr>
      <tr>
    <td>3</td>	<td>Москва-Ярославль</td><td>2</td><td>3</td>
    </tr>
      <tr>
    <td>4</td>	<td>Москва-Кострома</td><td>2</td><td>4</td>
    </tr>
      <tr>
    <td>5</td>	<td>Москва-Волгорад</td><td>3</td><td>5</td>
    </tr>
      <tr>
    <td>6</td>	<td>Москва-Иваново</td><td>null</td><td>null</td>
    </tr>
 </table>


     
1. Реализовать прямое соединение двух или более таблиц
   - Прямое соединение- это INNER JOIN.
   - Слово INNER может быть опущено
   - Если ключи в двух таблицах совпадают, то будет возвращена строка, содержащая колонки из обеих таблиц

```sql
    SELECT * FROM routes r
    JOIN buses b ON r.bus_id = b.bus_id
    JOIN drivers d on r.driver_id = d.driver_id;

    SELECT * FROM routes r, buses b, drivers d
    WHERE r.bus_id = b.bus_id
    AND d.driver_id=r.driver_id ;
```
 <table>
    <tr>
    <th>route_id</th><th>name</th><th>bus_id</th><th>driver_id</th><th>bus_id</th><th>name</th><th>driver_id</th><th>first_name</th><th>second_name</th>
    </tr>
    <tr>
    <td>1</td><td>Москва-Болшево</td><td>1</td><td>1</td><td>1</td><td>ПАЗ</td><td>1</td><td>Иван</td><td>Иванов</td>
    </tr>
    <tr>
    <td>2</td><td>Москва-Пушкино</td><td>1</td><td>2</td><td>1</td><td>ПАЗ</td><td>1</td><td>Петр</td><td>Петров</td>
    </tr>
    <tr>
    <td>3</td><td>Москва-Ярославль</td><td>2</td><td>3</td><td>2</td><td>ЛИАЗ</td><td>3</td><td>Савелий</td><td>Сидоров</td>
    </tr>
    <tr>
    <td>4</td><td>Москва-Кострома</td><td>2</td><td>4</td><td>2</td><td>ЛИАЗ</td><td>4</td><td>Антон</td><td>Шторкин</td>
    </tr>
    <tr>
    <td>5</td><td>Москва-Волгорад</td><td>3</td><td>5</td><td>3</td><td>MAN</td><td>1</td><td>Олег</td><td>Зажигаев</td>
    </tr>
 </table>

### Если поля(ключи), по которым мы соединяем таблицы совпадают, то для сокращения записи можно использовать NATURAL JOIN или USING()
 ```sql
SELECT * FROM routes r
NATURAL JOIN drivers d
JOIN buses b USING (bus_id);
```

### Пример 2
### Создадим таблицу cats и таблицу tomstoes и сразу заполним их данными
 **Schema (PostgreSQL v12)**

    create table cats (color text, type_cat text);
    create table tomatoes (color text, type_tomato text);
    insert into cats values ('red', 'Gav');
    insert into tomatoes values ('red', 'Beefsteak');

---

### Выберем из двух таблиц совпадающие по цветам значения, используя INNER JOIN и WHERE
**Query #2**

    select *
    from cats c
    inner join tomatoes t
    on c.color = t.color;

| color | type_cat | color | type_tomato |
| ----- | -------- | ----- | ----------- |
| red   | Gav      | red   | Beefsteak   |

---
**Query #3**

    
    
    select * 
    from cats c, tomatoes t
    where c.color = t.color;

| color | type_cat | color | type_tomato |
| ----- | -------- | ----- | ----------- |
| red   | Gav      | red   | Beefsteak   |

---

### Пример 3

**Schema (PostgreSQL v12)**

    create table cats (color text, type_cat text);
    create table tomatoes (color text, type_tomato text);
    insert into cats values ('red', 'Gav');
    insert into cats values ('red', 'Gav2');
    insert into tomatoes values ('red', 'Beefsteak');

---

**Query #4**

    select * 
    from cats c 
    inner join tomatoes t
    on c.color = t.color;

| color | type_cat | color | type_tomato |
| ----- | -------- | ----- | ----------- |
| red   | Gav      | red   | Beefsteak   |
| red   | Gav2     | red   | Beefsteak   |

---

<!-- [View on DB Fiddle](https://www.db-fiddle.com/f/cy9vkGYgEY7KQhenqRdS9i/11) -->

### Мы использовали прямое соединение двух таблиц с помощью JOIN и WHERE.
### Во втором примере у нас два красных кота и один красный томат, и поэтому выбралось два разных кота а томат задублировался

# Реализовать левостороннее (или правостороннее) соединение двух или более таблиц
### Если ключи в двух таблицах совпадают, то будет возвращена строка, содержащая колонки из обеих таблиц
### Слово OUTER может быть опущено
### С случае left join , если для строки из левой таблицы не будет найдено строк с тем же ключом в правой таблице, то вернется строка из левой таблицы, но в том числе с колонками правой таблицы
### Итак, используем две таблицы: cats, tomatoes. В сторбец цвет вставим разные цвета и соединим таблицы left join.
### Слева расположим таблицу cats, и увидим, что выбралась ты строка которая была в cats. Но в таблице tomatoes соответствия не нашлось, поэтому ячейки заполнились null
### Соединение left join выбирает все строки из левой таблицы,  и из правой которые совпадут. В противном случае в правой таблице,  вернутся null, там где не совпало.
### Соединение right join - это операция с точностью наоборот. Выбираются все данные из правой таблицы и те которые совпадают в левой. Остальное(в левой таблице) добирается значениями null
### В следующем примере видно, что совпало одно значение, и мы видим в результирующей таблице первая строка содержит совпавшее значение из первой и из второй таблицы, а также значение из левой таблицы, которому не нашлось соответсвия в правой таблице
**Schema (PostgreSQL v12)**

    create table cats (color text, type_cat text);
    create table tomatoes (color text, type_tomato text);
    insert into cats values ('red', 'Gav');
    insert into tomatoes values ('green', 'Beefsteak');

---

**Query #1**

    select * 
    from cats c 
    left join tomatoes t
    on c.color = t.color;

| color | type_cat | color | type_tomato |
| ----- | -------- | ----- | ----------- |
| red   | Gav      |       |             |

---

**Schema (PostgreSQL v12)**

    create table cats (color text, type_cat text);
    create table tomatoes (color text, type_tomato text);
    insert into cats values ('red', 'Gav');
    insert into tomatoes values ('green', 'Beefsteak');

---

**Query #1**

    select * 
    from cats c 
    right join tomatoes t
    on c.color = t.color;

| color | type_cat | color | type_tomato |
| ----- | -------- | ----- | ----------- |
|       |          | green | Beefsteak   |

---

**Schema (PostgreSQL v12)**

    create table cats (color text, type_cat text);
    create table tomatoes (color text, type_tomato text);
    insert into cats values ('red', 'Gav');
    insert into cats values ('black', 'Unknown');
    insert into tomatoes values ('green', 'Beefsteak');
    insert into tomatoes values ('red', 'Beefsteak');

---

**Query #1**

    select * 
    from cats c 
    left join tomatoes t
    on c.color = t.color;

| color | type_cat | color | type_tomato |
| ----- | -------- | ----- | ----------- |
| red   | Gav      | red   | Beefsteak   |
| black | Unknown  |       |             |

---



# Реализовать кросс соединение двух или более таблиц
### Cross Join или перекрестное соединение создает набор строк, где каждая строка из одной таблицы соединяется с каждой строкой из второй таблицы
### При соединение Cross Join происходит перемножение исходных множеств друг на друга 
**Schema (PostgreSQL v12)**

    create table cats (color text, type_cat text);
    create table tomatoes (color text, type_tomato text);
    insert into cats values ('red', 'Gav');
    insert into cats values ('black', 'Unknown');
    insert into tomatoes values ('green', 'Beefsteak');
    insert into tomatoes values ('red', 'Beefsteak');

---

**Query #1**

    select * 
    from cats c 
    cross join tomatoes t;

| color | type_cat | color | type_tomato |
| ----- | -------- | ----- | ----------- |
| red   | Gav      | green | Beefsteak   |
| red   | Gav      | red   | Beefsteak   |
| black | Unknown  | green | Beefsteak   |
| black | Unknown  | red   | Beefsteak   |

---
```sql
CREATE TABLE buses (
    bus_id serial,
    name   varchar
);

CREATE TABLE drivers (
    driver_id   serial,
    first_name  varchar,
    second_name varchar
);

CREATE TABLE routes (
    route_id  serial,
    name      varchar,
    bus_id    int,
    driver_id int
);

INSERT INTO buses
       (bus_id, name)
VALUES (1, 'ПАЗ'),
       (2, 'ЛИАЗ'),
       (3, 'MAN'),
       (4, 'МАЗ'),
       (5, 'НЕФАЗ');

	   INSERT INTO drivers
       (driver_id, first_name, second_name)
VALUES (1, 'Иван', 'Иванов'),
       (2, 'Петр', 'Петров'),
       (3, 'Савелий', 'Сидоров'),
       (4, 'Антон', 'Шторкин'),
       (5, 'Олег', 'Зажигаев'),
       (6, 'Аркадий', 'Паровозов');

	   INSERT INTO routes
       (route_id, name, bus_id, driver_id)
VALUES (1, 'Москва-Болшево', 1, 1),
       (2, 'Москва-Пушкино', 1, 2),
       (3, 'Москва-Ярославль', 2, 3),
       (4, 'Москва-Кострома', 2, 4),
       (5, 'Москва-Волгорад', 3, 5),
       (6, 'Москва-Иваново', null, null);
SELECT * FROM routes r
CROSS JOIN buses b
CROSS JOIN drivers d
"route_id"	"name"	"bus_id"	"driver_id"	"bus_id-2"	"name-2"	"driver_id-2"	"first_name"	"second_name"
1	"Москва-Болшево"	1	1	1	"ПАЗ"	1	"Иван"	"Иванов"
1	"Москва-Болшево"	1	1	2	"ЛИАЗ"	1	"Иван"	"Иванов"
1	"Москва-Болшево"	1	1	3	"MAN"	1	"Иван"	"Иванов"
......
Total rows 180
--- 6*6*5=180
```

# Реализовать полное соединение двух или более таблиц
### Если ключи в двух таблицах совпадают, то будет возвращена строка, содержащая колонки из обеих таблиц. Если соответствия не было найдено, то колонки из противоположной таблицы будкт пусты
**Schema (PostgreSQL v12)**

    create table cats (color text, type_cat text);
    create table tomatoes (color text, type_tomato text);
    insert into cats values ('red', 'Gav');
    insert into cats values ('black', 'Unknown');
    insert into tomatoes values ('green', 'Beefsteak');
    insert into tomatoes values ('red', 'Beefsteak');

---

**Query #1**

    select * 
    from cats c 
    full join tomatoes t
    on c.color = t.color;

| color | type_cat | color | type_tomato |
| ----- | -------- | ----- | ----------- |
| red   | Gav      | red   | Beefsteak   |
| black | Unknown  |       |             |
|       |          | green | Beefsteak   |

---

[View on DB Fiddle](https://www.db-fiddle.com/f/cy9vkGYgEY7KQhenqRdS9i/7)
**Schema (PostgreSQL v12)**

    create table cats (color text, type_cat text);
    create table tomatoes (color text, type_tomato text);
    insert into cats values ('red', 'Gav');
    insert into cats values ('black', 'Unknown');
    insert into tomatoes values ('green', 'Beefsteak');
    insert into tomatoes values ('red', 'Beefsteak');

---

**Query #1**

    select * 
    from cats c 
    full join tomatoes t
    on c.color = t.color
    where c.color is null or t.color is null;

| color | type_cat | color | type_tomato |
| ----- | -------- | ----- | ----------- |
| black | Unknown  |       |             |
|       |          | green | Beefsteak   |

---

[View on DB Fiddle](https://www.db-fiddle.com/f/cy9vkGYgEY7KQhenqRdS9i/8)

# Реализовать запрос, в котором будут использованы разные типы соединений
### Просто запрос в котором реализованы разные типы соединений

```sql
 SELECT  f.aircraft_code
  FROM flights f   
  RIGHT JOIN aircrafts_data c ON f.aircraft_code = c.aircraft_code
  CROSS JOIN airports_data d 
  UNION 
  SELECT aircraft_code FROM seats

```






