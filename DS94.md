### На 1 ВМ создаем таблицы test для записи, test2 для запросов на чтение
```sql
postgres=# create table test as
select
  generate_series(1,10) as id,
  md5(random()::text)::char(10) as fio;
SELECT 10
postgres=# create table test2 as
select
  generate_series(1,10) as id,
  md5(random()::text)::char(10) as fio;
SELECT 10
```
###

```sql
postgres=# create publication test_pub for table test;
WARNING:  wal_level is insufficient to publish logical changes
HINT:  Set wal_level to "logical" before creating subscriptions.
CREATE PUBLICATION
```

#### Вышло предупреждение, что уровня wal_level недостаточно для публикации
```sql
postgres=# show wal_level ;
 wal_level
-----------
 replica
(1 row)
```
##### Проверим уровень, да уровень replica. Со значением replica(он по умолчанию) в журнал записываются данные, необходимые для поддержки архивирования wal и репликации, включая запросы только на чтение на ведомом сервере. Minimal сохраняет только информацию, необходимую для восстановления после аварийного отключения. Logical добавляет информацию, требующуюся для поддержки логического декодирования. Задать параметр можно только при перезапуске сервера. Сделаем это.

```sql
postgres=# alter system set wal_level = logical;
ALTER SYSTEM
root@compute-vm-2-2-20-ssd-1743663539012:~#  pg_ctlcluster 16 main restart
postgres=# show wal_level ;
 wal_level
-----------
 logical
(1 row)


postgres=# \dRp+
                            Publication test_pub
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.test"
```
### Ок, попробуем создать холодную резервную копию и закинуть ее на вторую виртуалку
#### Отсанавливаем обе виртуалки
```sql
root@compute-vm-2-2-20-ssd-1743663578399:~# pg_ctlcluster 16 main stop
root@compute-vm-2-2-20-ssd-1743663539012:~# pg_ctlcluster 16 main stop
```
#### Генерируем ключи ssh для них. Копируем публичные  ключи в файл  authorized_keys


```bash
 ssh-keygen -t rsa -b 2048
cat /home/gpadmin/.ssh/id_rsa.pub
vim /home/gpadmin/.ssh/authorized_keys
```
#### На втором сервере, зачищаем директорию main
```bash
root@compute-vm-2-2-20-ssd-1743663578399:~# rm -rf /var/lib/postgresql/16/main/*
root@compute-vm-2-2-20-ssd-1743663578399:~#
```
#### Пробуем скопировать папку с данными с парвого на второй сервер
```bash
user@compute-vm-2-2-20-ssd-1743663578399:~$ scp -r user@10.130.0.12:/var/lib/postgresql/16/main /var/lib/postgresql/16/
scp: remote readdir("/var/lib/postgresql/16/main"): Permission denied
scp: remote readdir "/var/lib/postgresql/16/main" failed

```
#### Не получилось т.к. на удаленном сервере не пустил в директорию main. Посмотрим права на нее, и видим, что читать с нее может только пользователь postgres, а мы копируем под user. Поменяем на время копирования права
```bash
root@compute-vm-2-2-20-ssd-1743663578399:~# chown user:user /var/lib/postgresql/16/main/
user@compute-vm-2-2-20-ssd-1743663578399:~$ scp -r user@10.130.0.12:/var/lib/postgresql/16/main /var/lib/postgresql/16/
```
#### После копирования вернем права обратно. И проверим работу
```bash
root@compute-vm-2-2-20-ssd-1743663578399:~# chown -R postgres:postgres /var/lib/postgresql/16/main/
root@compute-vm-2-2-20-ssd-1743663578399:~#
root@compute-vm-2-2-20-ssd-1743663578399:~# pg_ctlcluster 16 main restart
root@compute-vm-2-2-20-ssd-1743663578399:~#
user@compute-vm-2-2-20-ssd-1743663578399:~$ sudo -i
root@compute-vm-2-2-20-ssd-1743663578399:~# pg_ctlcluster 16 main restart
root@compute-vm-2-2-20-ssd-1743663578399:~# su - postgres
postgres@compute-vm-2-2-20-ssd-1743663578399:~$ psql
psql (16.8 (Ubuntu 16.8-0ubuntu0.24.04.1))
Type "help" for help.

postgres=# \dt+
                                      List of relations
 Schema |  Name   | Type  |  Owner   | Persistence | Access method |    Size    | Description
--------+---------+-------+----------+-------------+---------------+------------+-------------
 public | student | table | postgres | permanent   | heap          | 8192 bytes |
 public | test    | table | postgres | permanent   | heap          | 8192 bytes |
 public | test2   | table | postgres | permanent   | heap          | 8192 bytes |
(3 rows)

postgres=# select * from test limit 3;
 id |    fio
----+------------
  1 | be75302499
  2 | a46bec8412
  3 | 0d135f1590
(3 rows)

postgres=#

```
#### На основном сервере тоже все вернем назад и запустим сервер
```bash
root@compute-vm-2-2-20-ssd-1743663539012:~# chmod -R 700 /var/lib/postgresql/16/main/
root@compute-vm-2-2-20-ssd-1743663539012:~# pg_ctlcluster 16 main restart
root@compute-vm-2-2-20-ssd-1743663539012:~# su - postgres
postgres@compute-vm-2-2-20-ssd-1743663539012:~$ psql
psql (16.8 (Ubuntu 16.8-0ubuntu0.24.04.1))
Type "help" for help.

postgres=# \dt+
                                      List of relations
 Schema |  Name   | Type  |  Owner   | Persistence | Access method |    Size    | Description
--------+---------+-------+----------+-------------+---------------+------------+-------------
 public | student | table | postgres | permanent   | heap          | 8192 bytes |
 public | test    | table | postgres | permanent   | heap          | 8192 bytes |
 public | test2   | table | postgres | permanent   | heap          | 8192 bytes |
(3 rows)

postgres=# select * from test limit 3;
 id |    fio
----+------------
  1 | be75302499
  2 | a46bec8412
  3 | 0d135f1590
(3 rows)

postgres=#

```
#### Все работает
#### Тут один момент, что таблица с публикацией тоже перешла на новый сервер, поэтому пересоздадим таблицы и удалим публикацию
```sql
postgres=# drop table test;
DROP TABLE
postgres=# drop table test2;
DROP TABLE
postgres=# drop publication test_pub;
DROP PUBLICATION
postgres=#

```
### Создаем публикацию таблицы test2 и подписываемся на публикацию таблицы test1 с ВМ №1.
```sql
postgres=# create subscription test_sub connection 'host=10.130.0.12 port=5432 password=postgres dbname=postgres' publication test_pub with ( copy_data = true);
NOTICE:  created replication slot "test_sub" on publisher
CREATE SUBSCRIPTION
postgres=# truncate test;
TRUNCATE TABLE
```
#### На первом сервере публикаторе вставим строку
```sql
postgres=# insert into test values (101,'ffwedf3');
INSERT 0 1

```
#### На втором сервере подписчике проверим
```sql
postgres=# select * from test;
 id  |    fio
-----+------------
 101 | ffwedf3
(1 row)

```
#### На втором сервере создадим публикацию второй таблицы

```sql
postgres=# create publication test2_pub for table test2;
CREATE PUBLICATION
postgres=# \dRp+
                           Publication test2_pub
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.test2"

```
#### На первом сервере подпишемся на нее
```sql
postgres=# create subscription test2_sub connection 'host=10.130.0.16 port=5432 password=postgres dbname=postgres' publication test2_pub with ( copy_data = true);
NOTICE:  created replication slot "test2_sub" on publisher
CREATE SUBSCRIPTION
postgres=# truncate test2;
TRUNCATE TABLE
postgres=# select * from test2;
 id | fio
----+-----
(0 rows)
```
#### На втором сервере вставим строку
```sql
postgres=# insert into test2 values (102,'123qwe123');
INSERT 0 1


```
#### На первом проверим

```sql
postgres=# select * from test2;
 id  |    fio
-----+------------
 102 | 123qwe123
(1 row)

```





